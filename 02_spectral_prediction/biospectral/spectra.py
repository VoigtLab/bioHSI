import pandas as pd
import pickle
import numpy as np
import re
import argparse
import json 

def get_args():
    options = argparse.ArgumentParser()
    options.add_argument("--singlets", dest="singlets_file", type=str)
    options.add_argument("--out-file", dest="out_file", type=str)
    options.add_argument("--lower-bound", dest="lower_bound", type=int)
    options.add_argument("--upper-bound", dest="upper_bound", type=int)
    options.add_argument("--fixed-width", dest="fixed_width", action='store_true', default=False)
    options.add_argument("--bars-out-file", dest="bars_out_file", type=str, default=None)
    options.add_argument("-s", dest="s", type=float, default=1)
    options.add_argument("--f-thresh", dest="f_thresh", type=float, default=0.0)
    args = options.parse_args()
    return args


# see https://gaussian.com/uvvisplot/
def make_peak(lbdas, lbda_0, f, fixed_width, s):
    """
    Perform a convolution around one excited state calculation
    see https://gaussian.com/uvvisplot/

    Parameters
    ----------
    lbdas: list of float
        The wavelengths at which to calculate the spectrum
    lbda_0: list of float
            The wavelength of maximum absorption (from TD-DFT)
    f: list of float
            Oscillator strength (from TD-DFT)
    fixed_width: bool
            If true, return a peak with a fixed width (in nm), else
            width is a function of the peak position
    s: float, optional
            Width parameter for the convolution gaussian function

    Returns
    -------
    peak : list of float
        A gaussian curve centered at lbda_0
    """
    if fixed_width:
        peak = (
            f
            / s
            * np.exp(-np.square((lbdas - lbda_0) / (s)) / 2)
        )
    else:
        peak = (
            40489.9942104
            * f
            / s
            * np.exp(-np.square((1 / lbdas - 1 / lbda_0) / (s / 3099.6)))
        )
    return peak


def make_spectrum(lbdas, lbda_0_ls, f_ls, fixed_width, s, f_thresh):
    """
    Construct an absorption spectrum from TD-DFT output data

    Parameters
    ----------
    lbdas: list of float
        The wavelengths at which to calculate the spectrum
    lbda_0_ls: list of float
            Wavelengths of maximum absorption (from TD-DFT)
    f: list of float
            Oscillator strengths (from TD-DFT)
    s: float
            Width parameter for the convolution gaussian function
    f_thresh: float
            Threshold value for the oscillator strength value of the excitation

    Returns
    -------
    spectrum : list of float
        A gaussian curve centered at lbda_0
    """
    spec = np.sum(
        [make_peak(lbdas, lbda_0, f, fixed_width, s) for lbda_0, f in zip(lbda_0_ls, f_ls) if f > f_thresh], axis=0
    )
    return spec


def parse_tddft_txt(out_file):
    """
    Parse summary output file from Gaussian TD-DFT simulation

    Parameters:
    -----------
    out_file: string
            Path to TD-DFT summary data file
            The file can be generated by running 'grep "Excited State" *log > out_file'
    Returns:
    ---------
    results: dictionary
            dictionary of the form {chemical name: [(l1, f1), ...]}
            where l is an excitation wavelength and f is the
            corresponding oscillation strength
    lambdas: list of floats
            List of the wavelengths
    fs: list of floats
            List of the oscillator strengths
    """
    with open(out_file, "r") as f:
        lines = f.readlines()
    results = {}
    lambdas = []
    fs = []
    for line in lines:
        name = line.split(".log")[0]
        if not name in results.keys():
            results[name] = []
        try:
            l_pat = re.compile("(?<=eV)\s*\d+\.\d+\s*(?=nm)")
            f_pat = re.compile("(?<=f=)\d*\.\d*")
            l = float(re.search(l_pat, line).group(0).strip())
            f = float(re.search(f_pat, line).group(0).strip())
            results[name].append((l, f))
            lambdas.append(l)
            fs.append(f)
        except:
            print ('Unable to read line:', line)
    return results, lambdas, fs


def make_spectra_df(results, nm_range, fixed_width, s, f_thresh=0.0):
    spectra = {}
    x = np.array(range(int(nm_range[0]), int(nm_range[1])))
    for i in results:
        fs = [f for _, f in results[i]]
        ls = [l for l, _ in results[i]]
        spectra[i] = make_spectrum(x, ls, fs, fixed_width, s, f_thresh)
    spectra_df = pd.DataFrame(spectra)
    spectra_df.index = x
    return spectra_df


def pick_spectra(spectra_df):
    # need to add modularity on how to pick
    summed = pd.DataFrame(
        {
            "350": spectra_df.loc[320:380, :].sum(axis=0),
            "230": spectra_df.loc[200:280, :].sum(axis=0),
            "400": spectra_df.loc[400:450, :].sum(axis=0),
        }
    )
    df_320_380 = summed[
        np.all(
            [summed["230"] < 0.25e6, summed["350"] > 5e5, summed["400"] < 0.25e6],
            axis=0,
        )
    ]
    return df_320_380, summed


def calc_dist(v1, v2):
    return np.sqrt(np.sum(np.square(v1 - v2)))


def main():
    args = get_args()
    results, lambdas, _ = parse_tddft_txt(args.singlets_file)
    if args.bars_out_file is not None:
        with open(args.bars_out_file, 'w') as f:
            f.write(json.dumps(results))

    upper_bound = args.upper_bound
    lower_bound = args.lower_bound
    fixed_width = args.fixed_width

    if not upper_bound:
        upper_bound = np.max(lambdas)
    if not lower_bound:
        lower_bound = np.min(lambdas)

    spectra_df = make_spectra_df(results, (lower_bound, upper_bound), fixed_width, args.s, args.f_thresh)
    print ('Saving results to {}'.format(args.out_file))
    spectra_df.to_csv(args.out_file)
